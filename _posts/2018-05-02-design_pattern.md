---
layout: post
title: "Design Pattern"
categories: [S/W Engineering]
tags: [Design Pattern]
---

개인적으로는 디자인 패턴이 얼마나 유용한지 모르겠다. 설계를 하다보면 자연스럽게 떠올리는 개념들인데 거창하게 이름만 붙인 것 같고, 몇몇 패턴은 현실의 복잡한 문제를 풀기에는 크게 도움이 안되는 것 같다. 그래도 이해해 두면 나쁠 것은 없으니 정리 차원에서 UML로 한 번 그려봤다. 패턴 자체보다는 패턴이 도출된 과정이 재미있고 의미가 있는 것 같다.

- Abstract Factory
![](/media/posts/design_pattern/abstract_factory.svg)

- Builder

![](/media/posts/design_pattern/builder.svg)

- Factory Method
  - 물류 시스템을 만든다고 해보자. 육상 물류, 해상 물류, 항공 물류, 기타 등등의 물류 클래스가 있고, 물류 클래스의 인터페이스는 주문(); 이동(); 등등이 될 것이다. 물류 시스템의 코드 내에는 육상 물류, 해상 물류, 항공 물류의 인스턴스를 생성하는 부분이 많을텐데, 그것이 코드 전체에 흩뿌려져 있다면, 물류 종류가 삭제되거나 추가될 경우 해당 부분을 모두 수정해야하는 불편이 따른다. 따라서 인스턴스 생성을 한 군데에서 관리해줄 필요가 있다. 인스턴스 생성만 해주는 역할이므로 팩토리라는 이름이 어울린다. 팩토리는 언제나 물류 클래스의 인터페이스만을 리턴하므로, 물류의 종류가 추가/삭제 된다고 하더라도 전체 코드에 영향을 주지 않는다. 따라서 코드의 유지 보수가 쉽다.
![](/media/posts/design_pattern/factory_method.svg)

- Prototype
  - 어떤 오브젝트의 복사본을 만든다고 생각해보자. 해당 오브젝트를 찍어낸 클래스를 가져와서 새로운 오브젝트를 생성한 뒤, 필드 값들을 그대로 복사해줘야 한다. 여기에는 두 가지 문제점이 있다. 1. 접근할 수 없는 필드가 있을 수 있기 때문에 복사를 못할 수 있다. 2. 오브젝트 생성시, 클래스를 참조해야하기 때문에 생성 코드 부분이 해당 클래스에 종속된다. 이 문제를 해결하기 위해, clone()이라는 인터페이스를 갖는 프로토타입 클래스를 정의하고 이 인터페이스를 구현하는 클래스들은 자기 자신의 복사본을 만들어 리턴한다.
![](/media/posts/design_pattern/prototype.svg)

- Adapter

![](/media/posts/design_pattern/adapter.svg)

- Bridge
  - 브릿지는 서로 다른 두 개를 연결하는 존재다. 그렇다면 왜 연결할까? 뭔가 함께 해야 할 일이 있기 때문이겠지. Linux와 Windows에서 동작해야 하는 어떤 GUI클래스를 구현한다고 해보자. GUI클래스는 Linux던 Windows던 일관된 인터페이스를 가져야 그걸 사용하는 Application의 이식성이 높아질 것이다. 그래서 보통 GUI클래스의 인터페이스를 정의하고, 그 인터페이스를 상속받아 Linux용 GUI클래스와 Windows용 GUI클래스를 각각 만들게 된다. 그런데 이 때 문제 발생. GUI클래스가 세분화 된다면? 예를 들어 어린이용 GUI클래스가 필요하고, 노인용 GUI클래스가 필요하다면? 각각에 대해 모두 Linux, Windows 버전을 만들어야 한다. 뭔가 잘못된 느낌이 든다. GUI클래스의 구현은 2가지를 포함하고 있다. 하나는 로직. 하나는 OS의존적인 동작. 로직 구현은 추상화된 인터페이스에 따라 구현되었으나, OS에 의존적인 동작은 아직 단순 구현에 머물러있다. 따라서 OS의존적인 동작을 추상화된 OS 클래스로 만들고, 그에 따라 각각(Linux/Windows) 구현한 후 두 구현을 브릿지로 연결한다. OS 클래스가 하위 Layer 개념이므로, GUI 클래스에서 OS 클래스의 구현 참조를 가지도록 하고, 필요에 따라 OS 클래스의 인터페이스를 호출하도록 하자. 참조가 브릿지인 셈. 이렇게 되면 로직의 분화는 GUI클래스가 담당하게 되고, OS의 분화는 OS 클래스가 담당하게 된다. 당연히 확장,수정,이식에 유리해진다.  
![](/media/posts/design_pattern/bridge.svg)

- Composite

![](/media/posts/design_pattern/composite.svg)

- Decorator

![](/media/posts/design_pattern/decorator.svg)

- Facade
  - 복잡한 인터페이스를 잔뜩 가진 상세 클래스들이 잔뜩 있다고 가정하자. 이런 클래스들을 가지고 전체 시스템을 꾸미려면, 인터페이스들이 너무 많아 복잡하다. 중간 수준의 추상화된 인터페이스가 필요하다는 얘기. 복잡한 인터페이스를 가진 클래스들을 목적에 맞게 묶어서 중간 수준의 추상화 인터페이스 클래스를 만들어야 한다. 뭐 당연한 얘기를 패턴처럼 얘기하는 것도 좀 웃기지만, 처음부터 시스템을 꾸미는 것이 아니라, 기존에 존재하는 여러 클래스들을 재사용해서 시스템을 꾸민다면 한 번쯤 생각해 볼 만하다. 어댑터는 추상화 수준을 조정하는 것이 아니다. 단순히 인터페이스를 변환만 하기 때문에 퍼사드와 다르다.

- Flyweight
  - 게임에서 사용되는 총알 클래스를 생각해보자. 총알의 좌표, 모양 이미지, 속도, 효과 이미지 등이 총알 클래스의 데이터가 될 것이다. 그런데 생각해보면, 각 총알마다 달라야하는 데이터는 좌표, 속도 등이고, 총알의 모양 이미지나 효과 이미지 등은 아마 대부분이 같을 것이다. 게임 내에서 사용되는 총알의 모양과 효과는 몇 개 없을 테니까. 따라서 총알 오브젝트가 모두 모양 이미지나 효과 이미지를 가지는 것은 낭비다. 총알 모양이나 효과 데이터를 다른 오브젝트에 생성해 두고, 총알 클래스에서는 참조만 하는 형태로 하는 것이 효율적이다. 이것도 써놓고 보니 당연한건데..암튼 이런 걸 플라이웨이트 패턴이라고 한다. 그리고 당연히 총알 모양이나 효과 데이터를 담은 오브젝트들은 수정 불가다.

- Proxy

![](/media/posts/design_pattern/proxy.svg)

- Chain of Responsibility

![](/media/posts/design_pattern/chain_of_responsibility.svg)

- Interpreter
- Iterator
- Mediator
- Memento
- Observer
- State
- Strategy
- Template Method
- Visitor

![](/media/posts/design_pattern/visitor.svg)
